var __wpo = {"assets":{"main":["/packs/base_polyfills.js","/packs/extra_polyfills.js","/packs/features/compose.js","/packs/modals/onboarding_modal.js","/packs/emoji_picker.js","/packs/features/notifications.js","/packs/features/account_timeline.js","/packs/features/home_timeline.js","/packs/features/public_timeline.js","/packs/features/community_timeline.js","/packs/features/favourited_statuses.js","/packs/features/list_timeline.js","/packs/features/following.js","/packs/features/followers.js","/packs/features/hashtag_timeline.js","/packs/features/status.js","/packs/features/account_gallery.js","/packs/features/blocks.js","/packs/features/follow_requests.js","/packs/features/reblogs.js","/packs/features/favourites.js","/packs/features/getting_started.js","/packs/features/keyboard_shortcuts.js","/packs/features/generic_not_found.js","/packs/features/list_editor.js","/packs/status/media_gallery.js","/packs/share.js","/packs/application.js","/packs/about.js","/packs/public.js","/packs/mailer.js","/packs/default.js","/packs/admin.js","/packs/common.js","/packs/common.css","/packs/mailer.css","/packs/default.css","/packs/manifest.json"],"additional":["/emoji/1f602.svg","/emoji/sheet.png"],"optional":["/packs/locale_zh-TW.js","/packs/locale_zh-HK.js","/packs/locale_zh-CN.js","/packs/locale_uk.js","/packs/locale_tr.js","/packs/locale_th.js","/packs/locale_sv.js","/packs/locale_sr.js","/packs/locale_sr-Latn.js","/packs/locale_sk.js","/packs/locale_ru.js","/packs/locale_pt.js","/packs/locale_pt-BR.js","/packs/locale_pl.js","/packs/locale_oc.js","/packs/locale_no.js","/packs/locale_nl.js","/packs/locale_ko.js","/packs/locale_ja.js","/packs/locale_it.js","/packs/locale_io.js","/packs/locale_id.js","/packs/locale_hy.js","/packs/locale_hu.js","/packs/locale_hr.js","/packs/locale_he.js","/packs/locale_gl.js","/packs/locale_fr.js","/packs/locale_fi.js","/packs/locale_fa.js","/packs/locale_es.js","/packs/locale_eo.js","/packs/locale_en.js","/packs/locale_de.js","/packs/locale_ca.js","/packs/locale_bg.js","/packs/locale_ar.js","/packs/roboto-italic-webfont-50efdad8c62f5f279e3f4f1f63a4f9bc.woff2","/packs/roboto-bold-webfont-f633cb5c651ba4d50791e1adf55d3c18.woff2","/packs/roboto-medium-webfont-69c55fc2fe77d38934ea98dc31642ce6.woff2","/packs/roboto-regular-webfont-3ec24f953ed5e859a6402cb3c030ea8b.woff2","/packs/fontawesome-webfont-af7ae505a9eed503f8b8e6982036873e.woff2","/packs/robotomono-regular-webfont-6c1ce30b90ee993b22618ec489585594.woff2","/packs/Montserrat-Regular-080422d4c1328f3407818d25c86cce51.woff2","/packs/void-65dfe5bd31335a5b308d36964d320574.png","/packs/reticle-7d7ce959271e5ff1193fb32cff90ea56.png","/packs/elephant-fren-d16fd77f9a9387e7d146b5f9d4dc1e7f.png","/packs/icon_cached-98a757f1d9e93652742be43c22f46287.png","/packs/icon_done-12b87c12f915597dccbd2ca4d7167ba4.png","/packs/icon_email-738c89662d6640f5e6539151023d049a.png","/packs/icon_file_download-e5c29678f3a639e1e62374911d85e1d0.png","/packs/icon_grade-3ec67253b37908d2ab783f7225f20682.png","/packs/icon_lock_open-0bfd71a52eb3f34934edd59088b559fb.png","/packs/icon_person_add-e2c6b660f6e1c95785d8d2bfa7a823af.png","/packs/icon_reply-4f6ada7a0b886b084706a484753a0ff0.png","/packs/logo_full-5c51cffe1fcb8225ae02400d6a7e7077.png","/packs/logo_transparent-6f79eeb2c38ec2d12ed4d978322457d6.png","/packs/preview-9a17d32fc48369e8ccd910a75260e67d.jpg","/packs/elephant_ui_plane-e3f2d57c12c376e189c274cbe81af8dd.svg","/packs/elephant_ui_disappointed-8864342480c3612e3061702851d3a798.svg","/packs/elephant_ui_greeting-475430963d0b00fe82b07b17857ebf6c.svg","/packs/elephant_ui_working-2e653cc278c2ac871c23aeb10de1c0e2.svg","/packs/icon_cached-108e30d96e1d5152be7fe2978bcdfe14.svg","/packs/icon_done-dba357bfbba455428787fefc655ce120.svg","/packs/icon_email-1346985c7aaceb601b0d4257133254f4.svg","/packs/icon_file_download-4b5c054e76b0df3cbbc851854cd10c3c.svg","/packs/icon_grade-8e81b8e88c2b5834347a2a226c65d440.svg","/packs/icon_lock_open-c9627928caaaa505ac7de2a64bd065ec.svg","/packs/icon_person_add-5c56ef10b9e99e77a44d89041f4b77b5.svg","/packs/icon_reply-b5e28e1fe6acd4ec003e643e947f1c4a.svg","/packs/logo-fe5141d38a25f50068b4c69b77ca1ec8.svg","/packs/logo_alt-6090911445f54a587465e41da77a6969.svg","/packs/logo_full-96e7a97fe469f75a23a74852b2478fa3.svg","/packs/logo_transparent-6900bab180aa3a46c34425e5367a218f.svg"]},"externals":["/emoji/1f602.svg","/emoji/sheet.png"],"hashesMap":{"8aadd54157395376ea8c22827bde88e67f31358e":"/packs/roboto-italic-webfont-50efdad8c62f5f279e3f4f1f63a4f9bc.woff2","e2fc71044647b6edf7a3ba41429d5d626e63710a":"/packs/roboto-bold-webfont-f633cb5c651ba4d50791e1adf55d3c18.woff2","b66f9a200f8671202198f0238b4729e127bc0dac":"/packs/roboto-medium-webfont-69c55fc2fe77d38934ea98dc31642ce6.woff2","74f352b40a57789750d3c738c710a82cdb0f254a":"/packs/roboto-regular-webfont-3ec24f953ed5e859a6402cb3c030ea8b.woff2","d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c":"/packs/fontawesome-webfont-af7ae505a9eed503f8b8e6982036873e.woff2","1e149b7d5f1c5a5c4971cb523450118b1d50ed47":"/packs/robotomono-regular-webfont-6c1ce30b90ee993b22618ec489585594.woff2","c6aade94b414951dc75e41b6f30fc1fa93bf89fb":"/packs/Montserrat-Regular-080422d4c1328f3407818d25c86cce51.woff2","7e2065071fefe6d54f64b821bf575a0ab49b92c0":"/packs/void-65dfe5bd31335a5b308d36964d320574.png","f7e7808e34f32df8859ac9cef991858df4fc0bba":"/packs/reticle-7d7ce959271e5ff1193fb32cff90ea56.png","8523aa7b16b029770170cc12026e7c7d172d626d":"/packs/elephant_ui_plane-e3f2d57c12c376e189c274cbe81af8dd.svg","027d2ab934afd67b404426234750c08b516ec223":"/packs/elephant-fren-d16fd77f9a9387e7d146b5f9d4dc1e7f.png","2523b7002bda93c12af3b4b7f4d7a35fd52faf41":"/packs/elephant_ui_disappointed-8864342480c3612e3061702851d3a798.svg","2dace1e38e0d159660c56d838ad2ce22c0184661":"/packs/elephant_ui_greeting-475430963d0b00fe82b07b17857ebf6c.svg","42a8fc2f0526540979583534ec331a2d28d2575e":"/packs/elephant_ui_working-2e653cc278c2ac871c23aeb10de1c0e2.svg","22fac75a796b2bd2c6872cbd8d14bd325b00bb64":"/packs/icon_cached-108e30d96e1d5152be7fe2978bcdfe14.svg","e9cea6fd6e8034f60e0358a15956490831c66b03":"/packs/icon_done-dba357bfbba455428787fefc655ce120.svg","17604ec5d343bc1aee070a2197dae8fd78bdccef":"/packs/icon_email-1346985c7aaceb601b0d4257133254f4.svg","e4a88b85b09c072041e89acaa22ec362ece97f27":"/packs/icon_file_download-4b5c054e76b0df3cbbc851854cd10c3c.svg","75a26256446662fb331fd42b9849dfff235364d5":"/packs/icon_grade-8e81b8e88c2b5834347a2a226c65d440.svg","7a534f4811adb70a796a285fb70b93c87a9f4b94":"/packs/icon_lock_open-c9627928caaaa505ac7de2a64bd065ec.svg","08ef53f9228b3d24f2801ba942fc842599c39e34":"/packs/icon_person_add-5c56ef10b9e99e77a44d89041f4b77b5.svg","ad9a0479341f3a93a83c7cadab091569e459076c":"/packs/icon_reply-b5e28e1fe6acd4ec003e643e947f1c4a.svg","aa75bce521938954706802c15e393ea05663e5e0":"/packs/logo-fe5141d38a25f50068b4c69b77ca1ec8.svg","f573db9e5698b7a3541880875c3ce88fe03ebee2":"/packs/logo_alt-6090911445f54a587465e41da77a6969.svg","3b339fcffc64574bca7cd2521e25bfbea8c3cbbf":"/packs/logo_full-96e7a97fe469f75a23a74852b2478fa3.svg","12520e03b958c73d94a1f19644ca4d0b79c6505d":"/packs/logo_transparent-6900bab180aa3a46c34425e5367a218f.svg","dc0b5a8d2d7e67f84d37635137610c6c6d937058":"/packs/icon_cached-98a757f1d9e93652742be43c22f46287.png","58f810df15baa9109f9db7f800e31c0d011e6f0d":"/packs/icon_done-12b87c12f915597dccbd2ca4d7167ba4.png","828ed8086eacb6622609e9992950998ce0a1579b":"/packs/icon_email-738c89662d6640f5e6539151023d049a.png","c60492c5ceea92a0acb138f20e0a33dd1e553f6b":"/packs/icon_file_download-e5c29678f3a639e1e62374911d85e1d0.png","b60349291b7d31e9aa78b94aed0f6ce07171096f":"/packs/icon_grade-3ec67253b37908d2ab783f7225f20682.png","d80b4dd1135df4803cddc1c1f6646dd7fc601367":"/packs/icon_lock_open-0bfd71a52eb3f34934edd59088b559fb.png","3f2c7f54c1073569de3a7312fb9a055723f68898":"/packs/icon_person_add-e2c6b660f6e1c95785d8d2bfa7a823af.png","f7717ae34919e3c88a668b5d9426b5fdc868b0de":"/packs/icon_reply-4f6ada7a0b886b084706a484753a0ff0.png","ee2ae924bf02960749696f2c66890780ca321924":"/packs/logo_full-5c51cffe1fcb8225ae02400d6a7e7077.png","2a2ed7e6889f11e00656cb952d0704f762bf05ea":"/packs/logo_transparent-6f79eeb2c38ec2d12ed4d978322457d6.png","361cf83e570038228710feb587738d6b74308e26":"/packs/preview-9a17d32fc48369e8ccd910a75260e67d.jpg","5d4a359e92bd0db85142ef5d2032f978299fd931":"/packs/base_polyfills.js","7d08663792b58ef04a228b1b914a6533c1dad89c":"/packs/extra_polyfills.js","43ff472978310fae521c1442e7a83c35f7718526":"/packs/features/compose.js","a599e27be978462b0d5c44d97a4e69f0835a5b9b":"/packs/modals/onboarding_modal.js","27e8cc1e196a017efe4e3f18e5c7fa0ac2f822b6":"/packs/emoji_picker.js","9735fe27a4fff92fdf2ff2daab01664c6a01ea9c":"/packs/features/notifications.js","25000ed648d48e8f63b24b4517d5c30cc19f692c":"/packs/features/account_timeline.js","aa8f81e9de6d31c7475d8af56dcddefbb21e6d1b":"/packs/features/home_timeline.js","629d72621f5ea602e6aac484aa517d907a1704c9":"/packs/features/public_timeline.js","d5dd37bcf53ff8d632e3d75ae754d7ca8b70382a":"/packs/features/community_timeline.js","c3c4aef1c595d5d0dda3932ad3f6f5d09b81f21c":"/packs/features/favourited_statuses.js","3bfe61af0efd8baea67c3040aafcd5e915ec9264":"/packs/features/list_timeline.js","60009a6e220403c393f6b6c3ff15896d3386aaa9":"/packs/features/following.js","e2c609410d3d5af59831bf449a5524c6f4e11899":"/packs/features/followers.js","d5802f65587d3d9853f2102fc8d8ca503f323841":"/packs/features/hashtag_timeline.js","a1408df611d9352c112f758918e60dfea6fe5ef5":"/packs/features/status.js","e8fb6f14711bb5fb901f095d35489a2b8b3cc19c":"/packs/features/account_gallery.js","1a3f765e8badc38183ff6bbc3f4adde4306a4f7c":"/packs/features/blocks.js","11d0072a456c1d611798cbab2d5c1f77774e348e":"/packs/features/follow_requests.js","bbd300034c982135068bc0351255f5d53314b966":"/packs/features/reblogs.js","37473f955a099e92a65b62c4058c052bb1fddb8b":"/packs/features/favourites.js","819eeccce151a15ddd3698a6bb9d1db322409cb3":"/packs/features/getting_started.js","97d7197bee456cdbfa72ea59a127bf39ec4a5c4b":"/packs/features/keyboard_shortcuts.js","dfb831d7f4ef1a5e42a5e0da5079976e62854e73":"/packs/features/generic_not_found.js","bbdf2b7959500499bb1dfa7ebbdf491655f43b80":"/packs/features/list_editor.js","2c17d7d23aee17b52923f613267d055405502aea":"/packs/status/media_gallery.js","3f24044d94d1fb56d83491052723533d47c8980d":"/packs/share.js","e0a89e86ef5d9a7e78e45108d4b75e86da15b381":"/packs/application.js","c702e61b3ea0793ecc4366d076b7349bb1518b69":"/packs/about.js","44d05906d49cc88f9409473aaaf26b906f5b6892":"/packs/public.js","da3993d9f3408a1ab3dad4f7bdf02dc8da425dc3":"/packs/locale_zh-TW.js","069445f3f8b3ea9cd71eb12a87c6915f3e46989b":"/packs/locale_zh-HK.js","92a7e6c208910f5214444dc91aa27360c4c77f6d":"/packs/locale_zh-CN.js","a49b1cb687c9db73b917a9d927cafd1b1c3870ec":"/packs/locale_uk.js","1b34cb16a8c2d6eee4d4fc86dd2edd8a93c8a0a6":"/packs/locale_tr.js","cc1753b364aa7390dedc29504398e1fd8c23d8c6":"/packs/locale_th.js","8a22093161c324516acce1bd00c3ba5ac6c8b8f1":"/packs/locale_sv.js","08cb0789a22b4a4859ae4590a59fbbd4c628026e":"/packs/locale_sr.js","a3481ef4cecce5754d600e326c3dc33c12a0c001":"/packs/locale_sr-Latn.js","f66480cc039a99821ebc4dc26fca8ec4b3195556":"/packs/locale_sk.js","4f10c28c894e6b17b6f989e6e34899d2d497ab1e":"/packs/locale_ru.js","189eaf61b7a833d1222beae1fcf08660a97081bb":"/packs/locale_pt.js","3ed6633be74d664e812cf167d0b79237b346b8eb":"/packs/locale_pt-BR.js","e2d206b98ccf9e3578c7cda7bd491e11a36bd9a7":"/packs/locale_pl.js","f95a47f22fe522ea9f19aea427eccdb92d668463":"/packs/locale_oc.js","f3a63e3a9b667af7b8aae6677cca9cd5fa544450":"/packs/locale_no.js","1617607a224891aca21dbd955f1d8d748073553c":"/packs/locale_nl.js","15fdc87c04677827cf62f023e93dbe704b14ffe6":"/packs/locale_ko.js","7263a0c443b06193d76974cfd530db11137cc814":"/packs/locale_ja.js","24efd78e64e34023d7fccc6ed6f9e4c9317f606d":"/packs/locale_it.js","eef1fb80c7e2d7d9d9a53fc2d2ab42c49e090973":"/packs/locale_io.js","668463bcf41ce8971dfc2e03b4760a5769608f9d":"/packs/locale_id.js","546038783532ad3a0a3d64c4f9fdec0fe274cb1b":"/packs/locale_hy.js","dcacf3d9c920b82b61e1c5c1e530b4cd89bf86d6":"/packs/locale_hu.js","e6ea9a0c39af19c23dd268dfa42d02f3ef6f5286":"/packs/locale_hr.js","d6f92ff2dc28b2b129db3b70a50916f429363d16":"/packs/locale_he.js","223fb275136e05f90330126a6c36a053c4105212":"/packs/locale_gl.js","ab248c91990e6585e9c845400e78a87023c2fc66":"/packs/locale_fr.js","5edfbae7843ae0deb08e842365e6b969c8e4319e":"/packs/locale_fi.js","234deb4354ef553db8947ac96e2ceecd187570dd":"/packs/locale_fa.js","8eef75454b123fa84bcbd897bb0b76c8023b57c8":"/packs/locale_es.js","e0fd3a1f37cc3ea0d40755e0847ef91a50adf313":"/packs/locale_eo.js","76bf1c955e254301d6271e4a2d1b712d7544b2ef":"/packs/locale_en.js","36c9261b7bf3d23c4a7fe7da776a3f7c73f4cb24":"/packs/locale_de.js","c94a8f32ae92263346a0087c0de7b229d24b5c31":"/packs/locale_ca.js","60d0bb13db45157614defb53ea18733d1d2bfa02":"/packs/locale_bg.js","c7feb7e93d36072925660142802091c491b02e5c":"/packs/locale_ar.js","9c5b75dcad12d553d953dfa71e4a3913600ddd80":"/packs/mailer.js","bccfc356ca0d67eb35b045cd313996454ba2e9d5":"/packs/default.js","a216f9aa7a4fb009a2e0fccdb2d0e09b9c7e3368":"/packs/admin.js","b35564c272704e8c31ba5c730f1f536e24dab1f8":"/packs/common.js","63d5949a7f9065ed25c771b22883444dc420be1d":"/packs/common.css","2a742852e4241f6de4f33884bf01731c08a3851d":"/packs/mailer.css","b16bfa7a55ba0ecfd3c91f84f587f8875a238634":"/packs/default.css","0663f076d7e4cce086fbebc8b2aa66d29e1123d9":"/packs/manifest.json"},"strategy":"changed","responseStrategy":"cache-first","version":"2018-4-1 11:28:19","name":"webpack-offline:mastodon","pluginVersion":"4.8.4","relativePaths":false};

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/packs/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  var waitUntil = ExtendableEvent.prototype.waitUntil;
  var respondWith = FetchEvent.prototype.respondWith;
  var promisesMap = new WeakMap();

  ExtendableEvent.prototype.waitUntil = function (promise) {
    var extendableEvent = this;
    var promises = promisesMap.get(extendableEvent);

    if (promises) {
      promises.push(Promise.resolve(promise));
      return;
    }

    promises = [Promise.resolve(promise)];
    promisesMap.set(extendableEvent, promises);

    // call original method
    return waitUntil.call(extendableEvent, Promise.resolve().then(function processPromises() {
      var len = promises.length;

      // wait for all to settle
      return Promise.all(promises.map(function (p) {
        return p["catch"](function () {});
      })).then(function () {
        // have new items been added? If so, wait again
        if (promises.length != len) return processPromises();
        // we're done!
        promisesMap["delete"](extendableEvent);
        // reject if one of the promises rejected
        return Promise.all(promises);
      });
    }));
  };

  FetchEvent.prototype.respondWith = function (promise) {
    this.waitUntil(promise);
    return respondWith.call(this, promise);
  };
})();;
        'use strict';

if (typeof DEBUG === 'undefined') {
  var DEBUG = false;
}

function WebpackServiceWorker(params, helpers) {
  var loaders = helpers.loaders;
  var cacheMaps = helpers.cacheMaps;

  var strategy = params.strategy;
  var responseStrategy = params.responseStrategy;

  var assets = params.assets;
  var loadersMap = params.loaders || {};

  var hashesMap = params.hashesMap;
  var externals = params.externals;

  // Not used yet
  // const alwaysRevalidate = params.alwaysRevalidate;
  // const ignoreSearch = params.ignoreSearch;
  // const preferOnline = params.preferOnline;

  var CACHE_PREFIX = params.name;
  var CACHE_TAG = params.version;
  var CACHE_NAME = CACHE_PREFIX + ':' + CACHE_TAG;

  var STORED_DATA_KEY = '__offline_webpack__data';

  mapAssets();

  var allAssets = [].concat(assets.main, assets.additional, assets.optional);
  var navigateFallbackURL = params.navigateFallbackURL;
  var navigateFallbackForRedirects = params.navigateFallbackForRedirects;

  self.addEventListener('install', function (event) {
    console.log('[SW]:', 'Install event');

    var installing = undefined;

    if (strategy === 'changed') {
      installing = cacheChanged('main');
    } else {
      installing = cacheAssets('main');
    }

    event.waitUntil(installing);
  });

  self.addEventListener('activate', function (event) {
    console.log('[SW]:', 'Activate event');

    var activation = cacheAdditional();

    // Delete all assets which name starts with CACHE_PREFIX and
    // is not current cache (CACHE_NAME)
    activation = activation.then(storeCacheData);
    activation = activation.then(deleteObsolete);
    activation = activation.then(function () {
      if (self.clients && self.clients.claim) {
        return self.clients.claim();
      }
    });

    event.waitUntil(activation);
  });

  function cacheAdditional() {
    if (!assets.additional.length) {
      return Promise.resolve();
    }

    if (DEBUG) {
      console.log('[SW]:', 'Caching additional');
    }

    var operation = undefined;

    if (strategy === 'changed') {
      operation = cacheChanged('additional');
    } else {
      operation = cacheAssets('additional');
    }

    // Ignore fail of `additional` cache section
    return operation['catch'](function (e) {
      console.error('[SW]:', 'Cache section `additional` failed to load');
    });
  }

  function cacheAssets(section) {
    var batch = assets[section];

    return caches.open(CACHE_NAME).then(function (cache) {
      return addAllNormalized(cache, batch, {
        bust: params.version,
        request: params.prefetchRequest
      });
    }).then(function () {
      logGroup('Cached assets: ' + section, batch);
    })['catch'](function (e) {
      console.error(e);
      throw e;
    });
  }

  function cacheChanged(section) {
    return getLastCache().then(function (args) {
      if (!args) {
        return cacheAssets(section);
      }

      var lastCache = args[0];
      var lastKeys = args[1];
      var lastData = args[2];

      var lastMap = lastData.hashmap;
      var lastVersion = lastData.version;

      if (!lastData.hashmap || lastVersion === params.version) {
        return cacheAssets(section);
      }

      var lastHashedAssets = Object.keys(lastMap).map(function (hash) {
        return lastMap[hash];
      });

      var lastUrls = lastKeys.map(function (req) {
        var url = new URL(req.url);
        url.search = '';
        url.hash = '';

        return url.toString();
      });

      var sectionAssets = assets[section];
      var moved = [];
      var changed = sectionAssets.filter(function (url) {
        if (lastUrls.indexOf(url) === -1 || lastHashedAssets.indexOf(url) === -1) {
          return true;
        }

        return false;
      });

      Object.keys(hashesMap).forEach(function (hash) {
        var asset = hashesMap[hash];

        // Return if not in sectionAssets or in changed or moved array
        if (sectionAssets.indexOf(asset) === -1 || changed.indexOf(asset) !== -1 || moved.indexOf(asset) !== -1) return;

        var lastAsset = lastMap[hash];

        if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {
          moved.push([lastAsset, asset]);
        } else {
          changed.push(asset);
        }
      });

      logGroup('Changed assets: ' + section, changed);
      logGroup('Moved assets: ' + section, moved);

      var movedResponses = Promise.all(moved.map(function (pair) {
        return lastCache.match(pair[0]).then(function (response) {
          return [pair[1], response];
        });
      }));

      return caches.open(CACHE_NAME).then(function (cache) {
        var move = movedResponses.then(function (responses) {
          return Promise.all(responses.map(function (pair) {
            return cache.put(pair[0], pair[1]);
          }));
        });

        return Promise.all([move, addAllNormalized(cache, changed, {
          bust: params.version,
          request: params.prefetchRequest
        })]);
      });
    });
  }

  function deleteObsolete() {
    return caches.keys().then(function (keys) {
      var all = keys.map(function (key) {
        if (key.indexOf(CACHE_PREFIX) !== 0 || key.indexOf(CACHE_NAME) === 0) return;

        console.log('[SW]:', 'Delete cache:', key);
        return caches['delete'](key);
      });

      return Promise.all(all);
    });
  }

  function getLastCache() {
    return caches.keys().then(function (keys) {
      var index = keys.length;
      var key = undefined;

      while (index--) {
        key = keys[index];

        if (key.indexOf(CACHE_PREFIX) === 0) {
          break;
        }
      }

      if (!key) return;

      var cache = undefined;

      return caches.open(key).then(function (_cache) {
        cache = _cache;
        return _cache.match(new URL(STORED_DATA_KEY, location).toString());
      }).then(function (response) {
        if (!response) return;

        return Promise.all([cache, cache.keys(), response.json()]);
      });
    });
  }

  function storeCacheData() {
    return caches.open(CACHE_NAME).then(function (cache) {
      var data = new Response(JSON.stringify({
        version: params.version,
        hashmap: hashesMap
      }));

      return cache.put(new URL(STORED_DATA_KEY, location).toString(), data);
    });
  }

  self.addEventListener('fetch', function (event) {
    var url = new URL(event.request.url);
    url.hash = '';

    var urlString = url.toString();

    // Not external, so search part of the URL should be stripped,
    // if it's external URL, the search part should be kept
    if (externals.indexOf(urlString) === -1) {
      url.search = '';
      urlString = url.toString();
    }

    // Handle only GET requests
    var isGET = event.request.method === 'GET';
    var assetMatches = allAssets.indexOf(urlString) !== -1;
    var cacheUrl = urlString;

    if (!assetMatches) {
      var cacheRewrite = matchCacheMap(event.request);

      if (cacheRewrite) {
        cacheUrl = cacheRewrite;
        assetMatches = true;
      }
    }

    if (!assetMatches && isGET) {
      // If isn't a cached asset and is a navigation request,
      // fallback to navigateFallbackURL if available
      if (navigateFallbackURL && isNavigateRequest(event.request)) {
        event.respondWith(handleNavigateFallback(fetch(event.request)));

        return;
      }
    }

    if (!assetMatches || !isGET) {
      // Fix for https://twitter.com/wanderview/status/696819243262873600
      if (url.origin !== location.origin && navigator.userAgent.indexOf('Firefox/44.') !== -1) {
        event.respondWith(fetch(event.request));
      }

      return;
    }

    // Logic of caching / fetching is here
    // * urlString -- url to match from the CACHE_NAME
    // * event.request -- original Request to perform fetch() if necessary
    var resource = undefined;

    if (responseStrategy === 'network-first') {
      resource = networkFirstResponse(event, urlString, cacheUrl);
    }
    // 'cache-first'
    // (responseStrategy has been validated before)
    else {
        resource = cacheFirstResponse(event, urlString, cacheUrl);
      }

    if (navigateFallbackURL && isNavigateRequest(event.request)) {
      resource = handleNavigateFallback(resource);
    }

    event.respondWith(resource);
  });

  self.addEventListener('message', function (e) {
    var data = e.data;
    if (!data) return;

    switch (data.action) {
      case 'skipWaiting':
        {
          if (self.skipWaiting) self.skipWaiting();
        }break;
    }
  });

  function cacheFirstResponse(event, urlString, cacheUrl) {
    return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {
      if (response) {
        if (DEBUG) {
          console.log('[SW]:', 'URL [' + cacheUrl + '](' + urlString + ') from cache');
        }

        return response;
      }

      // Load and cache known assets
      var fetching = fetch(event.request).then(function (response) {
        if (!response.ok) {
          if (DEBUG) {
            console.log('[SW]:', 'URL [' + urlString + '] wrong response: [' + response.status + '] ' + response.type);
          }

          return response;
        }

        if (DEBUG) {
          console.log('[SW]:', 'URL [' + urlString + '] from network');
        }

        if (cacheUrl === urlString) {
          (function () {
            var responseClone = response.clone();
            var storing = caches.open(CACHE_NAME).then(function (cache) {
              return cache.put(urlString, responseClone);
            }).then(function () {
              console.log('[SW]:', 'Cache asset: ' + urlString);
            });

            event.waitUntil(storing);
          })();
        }

        return response;
      });

      return fetching;
    });
  }

  function networkFirstResponse(event, urlString, cacheUrl) {
    return fetch(event.request).then(function (response) {
      if (response.ok) {
        if (DEBUG) {
          console.log('[SW]:', 'URL [' + urlString + '] from network');
        }

        return response;
      }

      // Throw to reach the code in the catch below
      throw new Error('Response is not ok');
    })
    // This needs to be in a catch() and not just in the then() above
    // cause if your network is down, the fetch() will throw
    ['catch'](function () {
      if (DEBUG) {
        console.log('[SW]:', 'URL [' + urlString + '] from cache if possible');
      }

      return cachesMatch(cacheUrl, CACHE_NAME);
    });
  }

  function handleNavigateFallback(fetching) {
    return fetching['catch'](function () {}).then(function (response) {
      var isOk = response && response.ok;
      var isRedirect = response && response.type === 'opaqueredirect';

      if (isOk || isRedirect && !navigateFallbackForRedirects) {
        return response;
      }

      if (DEBUG) {
        console.log('[SW]:', 'Loading navigation fallback [' + navigateFallbackURL + '] from cache');
      }

      return cachesMatch(navigateFallbackURL, CACHE_NAME);
    });
  }

  function mapAssets() {
    Object.keys(assets).forEach(function (key) {
      assets[key] = assets[key].map(function (path) {
        var url = new URL(path, location);

        url.hash = '';

        if (externals.indexOf(path) === -1) {
          url.search = '';
        }

        return url.toString();
      });
    });

    Object.keys(loadersMap).forEach(function (key) {
      loadersMap[key] = loadersMap[key].map(function (path) {
        var url = new URL(path, location);

        url.hash = '';

        if (externals.indexOf(path) === -1) {
          url.search = '';
        }

        return url.toString();
      });
    });

    hashesMap = Object.keys(hashesMap).reduce(function (result, hash) {
      var url = new URL(hashesMap[hash], location);
      url.search = '';
      url.hash = '';

      result[hash] = url.toString();
      return result;
    }, {});

    externals = externals.map(function (path) {
      var url = new URL(path, location);
      url.hash = '';

      return url.toString();
    });
  }

  function addAllNormalized(cache, requests, options) {
    var allowLoaders = options.allowLoaders !== false;
    var bustValue = options && options.bust;
    var requestInit = options.request || {
      credentials: 'omit',
      mode: 'cors'
    };

    return Promise.all(requests.map(function (request) {
      if (bustValue) {
        request = applyCacheBust(request, bustValue);
      }

      return fetch(request, requestInit).then(fixRedirectedResponse);
    })).then(function (responses) {
      if (responses.some(function (response) {
        return !response.ok;
      })) {
        return Promise.reject(new Error('Wrong response status'));
      }

      var extracted = [];
      var addAll = responses.map(function (response, i) {
        if (allowLoaders) {
          extracted.push(extractAssetsWithLoaders(requests[i], response));
        }

        return cache.put(requests[i], response);
      });

      if (extracted.length) {
        (function () {
          var newOptions = copyObject(options);
          newOptions.allowLoaders = false;

          var waitAll = addAll;

          addAll = Promise.all(extracted).then(function (all) {
            var extractedRequests = [].concat.apply([], all);

            if (requests.length) {
              waitAll = waitAll.concat(addAllNormalized(cache, extractedRequests, newOptions));
            }

            return Promise.all(waitAll);
          });
        })();
      } else {
        addAll = Promise.all(addAll);
      }

      return addAll;
    });
  }

  function extractAssetsWithLoaders(request, response) {
    var all = Object.keys(loadersMap).map(function (key) {
      var loader = loadersMap[key];

      if (loader.indexOf(request) !== -1 && loaders[key]) {
        return loaders[key](response.clone());
      }
    }).filter(function (a) {
      return !!a;
    });

    return Promise.all(all).then(function (all) {
      return [].concat.apply([], all);
    });
  }

  function matchCacheMap(request) {
    var urlString = request.url;
    var url = new URL(urlString);

    var requestType = undefined;

    if (request.mode === 'navigate') {
      requestType = 'navigate';
    } else if (url.origin === location.origin) {
      requestType = 'same-origin';
    } else {
      requestType = 'cross-origin';
    }

    for (var i = 0; i < cacheMaps.length; i++) {
      var map = cacheMaps[i];

      if (!map) continue;
      if (map.requestTypes && map.requestTypes.indexOf(requestType) === -1) {
        continue;
      }

      var newString = undefined;

      if (typeof map.match === 'function') {
        newString = map.match(url, request);
      } else {
        newString = urlString.replace(map.match, map.to);
      }

      if (newString && newString !== urlString) {
        return newString;
      }
    }
  }
}

function cachesMatch(request, cacheName) {
  return caches.match(request, {
    cacheName: cacheName
  }).then(function (response) {
    if (isNotRedirectedResponse()) {
      return response;
    }

    // Fix already cached redirected responses
    return fixRedirectedResponse(response).then(function (fixedResponse) {
      return caches.open(cacheName).then(function (cache) {
        return cache.put(request, fixedResponse);
      }).then(function () {
        return fixedResponse;
      });
    });
  })
  // Return void if error happened (cache not found)
  ['catch'](function () {});
}

function applyCacheBust(asset, key) {
  var hasQuery = asset.indexOf('?') !== -1;
  return asset + (hasQuery ? '&' : '?') + '__uncache=' + encodeURIComponent(key);
}

function getClientsURLs() {
  if (!self.clients) {
    return Promise.resolve([]);
  }

  return self.clients.matchAll({
    includeUncontrolled: true
  }).then(function (clients) {
    if (!clients.length) return [];

    var result = [];

    clients.forEach(function (client) {
      var url = new URL(client.url);
      url.search = '';
      url.hash = '';
      var urlString = url.toString();

      if (!result.length || result.indexOf(urlString) === -1) {
        result.push(urlString);
      }
    });

    return result;
  });
}

function isNavigateRequest(request) {
  return request.mode === 'navigate' || request.headers.get('Upgrade-Insecure-Requests') || (request.headers.get('Accept') || '').indexOf('text/html') !== -1;
}

function isNotRedirectedResponse(response) {
  return !response || !response.redirected || !response.ok || response.type === 'opaqueredirect';
}

// Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85
function fixRedirectedResponse(response) {
  if (isNotRedirectedResponse(response)) {
    return Promise.resolve(response);
  }

  var body = 'body' in response ? Promise.resolve(response.body) : response.blob();

  return body.then(function (data) {
    return new Response(data, {
      headers: response.headers,
      status: response.status
    });
  });
}

function copyObject(original) {
  return Object.keys(original).reduce(function (result, key) {
    result[key] = original[key];
    return result;
  }, {});
}

function logGroup(title, assets) {
  console.groupCollapsed('[SW]:', title);

  assets.forEach(function (asset) {
    console.log('Asset:', asset);
  });

  console.groupEnd();
}
        WebpackServiceWorker(__wpo, {
loaders: {},
cacheMaps: [],
});
        module.exports = __webpack_require__(1)
      

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__web_push_notifications__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__web_push_notifications___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__web_push_notifications__);
/*** IMPORTS FROM imports-loader ***/
var process = (process || {});
process.env = {"GJS_DEBUG_TOPICS":"JS ERROR;JS LOG","npm_config_cache_lock_stale":"60000","npm_config_ham_it_up":"","npm_package_dependencies_mark_loader":"^0.1.6","npm_config_legacy_bundling":"","npm_config_sign_git_tag":"","USER":"howl","LANGUAGE":"en_GB:en","npm_package_dependencies_autoprefixer":"^7.1.6","npm_package_dependencies_mkdirp":"^0.5.1","npm_package_dependencies_node_sass":"^4.7.2","npm_package_devDependencies_jest":"^21.2.1","npm_config_user_agent":"npm/5.6.0 node/v9.10.1 linux x64","npm_config_always_auth":"","COMP_WORDBREAKS":" \t\n\"'><;|&(:","XDG_SEAT":"seat0","npm_package_dependencies_detect_passive_events":"^1.0.2","npm_package_dependencies_immutable":"^3.8.2","npm_package_bugs_url":"https://github.com/tootsuite/mastodon/issues","npm_config_bin_links":"true","npm_config_key":"","SSH_AGENT_PID":"1323","XDG_SESSION_TYPE":"x11","npm_package_dependencies_react_overlays":"^0.8.3","npm_config_allow_same_version":"","npm_config_description":"true","npm_config_fetch_retries":"2","npm_config_heading":"npm","npm_config_if_present":"","npm_config_init_version":"1.0.0","npm_config_user":"","npm_node_execpath":"/usr/bin/node","LD_LIBRARY_PATH":"/home/howl/torch-cl/install/lib:","LUA_PATH":"/home/howl/.luarocks/share/lua/5.1/?.lua;/home/howl/.luarocks/share/lua/5.1/?/init.lua;/home/howl/torch-cl/install/share/lua/5.1/?.lua;/home/howl/torch-cl/install/share/lua/5.1/?/init.lua;./?.lua;/home/howl/torch-cl/install/share/luajit-2.1.0-beta1/?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua","SHLVL":"1","npm_package_scripts_manage_translations":"node ./config/webpack/translationRunner.js","npm_package_dependencies_babel_plugin_transform_class_properties":"^6.24.1","npm_package_dependencies_babel_plugin_transform_es2015_modules_commonjs":"^6.24.1","npm_package_dependencies_escape_html":"^1.0.3","npm_package_dependencies_imports_loader":"^0.8.0","npm_package_optionalDependencies_node_zopfli":"^2.0.2","npm_config_prefer_online":"","OLDPWD":"/home/howl/oc/mastofe/app","HOME":"/home/howl","npm_package_dependencies_postcss_loader":"^2.0.9","npm_config_force":"","OSU_API_KEY":"e0146ddaf01d1e9d107afedcd340b42347186260","DESKTOP_SESSION":"cinnamon","npm_package_dependencies_react_redux_loading_bar":"^2.9.3","npm_package_dependencies_redis":"^2.7.1","npm_config_only":"","npm_config_read_only":"","GIO_LAUNCHED_DESKTOP_FILE":"/usr/share/applications/xfce4-terminal.desktop","npm_package_engines_node":">=6","npm_package_dependencies_babel_plugin_react_intl":"^2.3.1","npm_package_dependencies_npmlog":"^4.1.2","npm_package_devDependencies_enzyme_adapter_react_16":"^1.1.0","npm_config_cache_min":"10","npm_config_init_license":"ISC","GTK_MODULES":"gail:atk-bridge","XDG_SEAT_PATH":"/org/freedesktop/DisplayManager/Seat0","npm_package_scripts_build_production":"cross-env NODE_ENV=production webpack --config config/webpack/production.js","npm_package_dependencies_glob":"^7.1.1","npm_package_dependencies_webpack_merge":"^4.1.1","npm_config_editor":"vi","npm_config_rollback":"true","npm_config_tag_version_prefix":"v","OSU_PASSWORD":"il mio cane gioca meglio di me","npm_package_dependencies_redux_thunk":"^2.2.0","npm_package_dependencies_webpack":"^3.9.1","npm_config_cache_max":"Infinity","npm_config_timing":"","npm_config_userconfig":"/home/howl/.npmrc","DBUS_SESSION_BUS_ADDRESS":"unix:path=/run/user/1000/bus","CINNAMON_VERSION":"3.6.7","npm_package_dependencies_babel_plugin_lodash":"^3.3.2","npm_package_dependencies_dotenv":"^4.0.0","npm_package_dependencies_precss":"^2.0.0","npm_package_dependencies_react_hotkeys":"^0.10.0","npm_config_engine_strict":"","npm_config_init_author_name":"","npm_config_init_author_url":"","npm_config_tmp":"/tmp","COLORTERM":"truecolor","GIO_LAUNCHED_DESKTOP_FILE_PID":"1943","npm_package_dependencies_react_router_dom":"^4.1.1","npm_package_description":"Here is a fork of mastodon. We could really just remove all of the code except for the frontend, but to easily pull the upstream repo we'll just keep everything. This is my fork for the moment with the idea of making the mastofe just as polished as the pleromafe. If you want to get access, open an issue or hit me up at howl@social.zxq.co.","npm_config_depth":"Infinity","npm_config_package_lock_only":"","npm_config_save_dev":"","npm_config_usage":"","npm_package_scripts_test_jest":"cross-env NODE_ENV=test jest --coverage","npm_package_dependencies_throng":"^4.0.0","npm_package_devDependencies_react_intl_translations_manager":"^5.0.0","npm_package_readmeFilename":"README.md","npm_package_homepage":"https://github.com/tootsuite/mastodon#readme","npm_config_metrics_registry":"https://registry.npmjs.org/","npm_config_cafile":"","npm_config_otp":"","npm_config_package_lock":"true","npm_config_progress":"true","npm_config_https_proxy":"","npm_config_save_prod":"","QT_QPA_PLATFORMTHEME":"gtk2","npm_package_scripts_dev":"cross-env NODE_ENV=development webpack-dev-server --config config/webpack/development.js --progress --color","npm_package_scripts_test_lint":"eslint -c .eslintrc.yml --ext=js app/javascript/ config/webpack/ streaming/","npm_package_dependencies_babel_plugin_transform_react_remove_prop_types":"^0.4.10","npm_package_dependencies_websocket_js":"^0.1.12","npm_config_cidr":"","npm_config_onload_script":"","npm_config_sso_type":"oauth","LOGNAME":"howl","npm_package_dependencies_babel_plugin_syntax_dynamic_import":"^6.18.0","npm_package_dependencies_hammerjs":"^2.0.8","npm_package_dependencies_rails_ujs":"^5.1.2","npm_package_dependencies_react_immutable_pure_component":"^1.1.1","npm_package_dependencies_react_motion":"^0.5.2","npm_package_dependencies_reselect":"^3.0.1","npm_package_devDependencies_eslint_plugin_import":"^2.8.0","npm_config_rebuild_bundle":"true","npm_config_save_bundle":"","npm_config_shell":"/bin/bash","WINDOWID":"77594627","_":"./build.sh","npm_package_private":"true","npm_package_dependencies_express":"^4.16.2","npm_package_dependencies_react_notification":"^6.8.2","npm_package_dependencies_sass_loader":"^6.0.6","npm_config_dry_run":"","npm_config_prefix":"/usr","npm_config_scope":"","npm_config_browser":"","npm_config_cache_lock_wait":"10000","npm_config_ignore_prepublish":"","npm_config_registry":"https://registry.npmjs.org/","npm_config_save_optional":"","npm_config_searchopts":"","npm_config_versions":"","GTK_OVERLAY_SCROLLING":"0","XDG_SESSION_ID":"2","TERM":"xterm-256color","npm_package_dependencies_font_awesome":"^4.7.0","npm_package_dependencies_postcss_object_fit_images":"^1.1.2","npm_package_dependencies_react_immutable_proptypes":"^2.1.0","npm_package_dependencies_style_loader":"^0.19.0","npm_package_dependencies_uws":"^8.14.0","npm_package_optionalDependencies_fsevents":"*","npm_config_cache":"/home/howl/.npm","npm_config_proxy":"","npm_config_send_metrics":"","GNOME_DESKTOP_SESSION_ID":"this-is-deprecated","npm_package_scripts_start":"node ./streaming/index.js","npm_config_global_style":"","npm_config_ignore_scripts":"","npm_config_version":"","npm_package_dependencies_axios":"~0.16.2","npm_package_dependencies_css_loader":"^0.28.4","npm_package_dependencies_marky":"^1.2.0","npm_config_local_address":"","npm_config_viewer":"man","npm_config_node_gyp":"/usr/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js","PATH":"/usr/lib/node_modules/npm/node_modules/npm-lifecycle/node-gyp-bin:/home/howl/oc/mastofe/node_modules/.bin:/home/howl/torch-cl/install/bin:/home/howl/go/bin:/home/howl/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games","SESSION_MANAGER":"local/pluto:@/tmp/.ICE-unix/1292,unix/pluto:/tmp/.ICE-unix/1292","npm_package_name":"mastodon","npm_package_repository_type":"git","npm_package_dependencies_babel_preset_env":"^1.6.1","npm_package_dependencies_cross_env":"^5.1.1","npm_package_dependencies_extract_text_webpack_plugin":"^3.0.2","npm_package_dependencies_substring_trie":"^1.0.2","npm_config_prefer_offline":"","NODE":"/usr/bin/node","XDG_RUNTIME_DIR":"/run/user/1000","XDG_SESSION_PATH":"/org/freedesktop/DisplayManager/Session0","npm_package_dependencies_babel_plugin_transform_runtime":"^6.23.0","npm_package_dependencies_react_redux":"^5.0.4","npm_package_dependencies_tiny_queue":"^0.2.1","npm_package_devDependencies_eslint_plugin_jsx_a11y":"^5.1.1","npm_config_color":"true","DISPLAY":":0","npm_package_scripts_build_development":"cross-env NODE_ENV=development webpack --config config/webpack/development.js","npm_package_dependencies_npm_run_all":"^4.1.2","npm_package_dependencies_stringz":"^0.3.0","npm_config_fetch_retry_mintimeout":"10000","npm_config_maxsockets":"50","npm_config_offline":"","npm_config_sso_poll_frequency":"500","LANG":"en_GB.UTF-8","XDG_CURRENT_DESKTOP":"X-Cinnamon","npm_package_dependencies_babel_plugin_transform_react_inline_elements":"^6.22.0","npm_package_dependencies_babel_preset_react":"^6.24.1","npm_package_dependencies_object_assign":"^4.1.1","npm_package_dependencies_react_dom":"^16.2.0","npm_package_dependencies_react_textarea_autosize":"^5.2.1","npm_package_dependencies_redux":"^3.7.1","npm_package_devDependencies_eslint":"^4.15.0","npm_package_devDependencies_react_test_renderer":"^16.2.0","npm_config_umask":"0022","LS_COLORS":"rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:","XDG_SESSION_DESKTOP":"cinnamon","XAUTHORITY":"/home/howl/.Xauthority","npm_package_dependencies_babel_plugin_transform_object_rest_spread":"^6.23.0","npm_package_dependencies_offline_plugin":"^4.8.3","npm_package_dependencies_path_complete_extname":"^0.1.0","npm_package_dependencies_postcss_smart_import":"^0.7.5","npm_package_dependencies_node_zopfli":"^2.0.2","npm_package_gitHead":"f48f11d488a1c48965317034a7a5fd470a4971f5","npm_config_fetch_retry_maxtimeout":"60000","npm_config_loglevel":"notice","npm_config_logs_max":"10","npm_config_message":"%s","npm_lifecycle_script":"cross-env NODE_ENV=production webpack --config config/webpack/production.js","SSH_AUTH_SOCK":"/run/user/1000/keyring/ssh","XDG_GREETER_DATA_DIR":"/var/lib/lightdm/data/howl","npm_package_scripts_postversion":"git push --tags","npm_package_scripts_test":"npm-run-all test:lint test:jest","npm_package_dependencies_babel_core":"^6.25.0","npm_package_dependencies_babel_plugin_preval":"^1.6.1","npm_package_dependencies_http_link_header":"^0.8.0","npm_package_dependencies_intersection_observer":"^0.5.0","npm_package_dependencies_is_nan":"^1.2.1","npm_package_dependencies_react_intl":"^2.4.0","npm_package_dependencies_react_router_scroll_4":"^1.0.0-beta.1","npm_package_dependencies_react_swipeable_views":"^0.12.3","npm_package_dependencies_redux_immutable":"^4.0.0","npm_package_devDependencies_webpack_dev_server":"^2.9.5","npm_config_ca":"","npm_config_cert":"","npm_config_global":"","npm_config_link":"","SHELL":"/bin/bash","npm_package_repository_url":"git+https://github.com/tootsuite/mastodon.git","npm_package_dependencies_webpack_bundle_analyzer":"^2.9.1","npm_package_version":"","npm_config_access":"","npm_config_also":"","npm_config_save":"true","npm_config_unicode":"true","npm_lifecycle_event":"build","QT_ACCESSIBILITY":"1","GDMSESSION":"cinnamon","npm_package_scripts_build":"cross-env NODE_ENV=production webpack --config config/webpack/production.js","npm_package_dependencies_emoji_mart":"github:Gargron/emoji-mart#build","npm_package_dependencies_intl":"^1.2.5","npm_package_dependencies_js_yaml":"^3.9.0","npm_package_dependencies_uuid":"^3.1.0","npm_config_argv":"{\"remain\":[],\"cooked\":[\"run\",\"build\"],\"original\":[\"run\",\"build\"]}","npm_config_long":"","npm_config_production":"","npm_config_searchlimit":"20","npm_config_unsafe_perm":"true","npm_package_dependencies_array_includes":"^3.0.3","npm_package_dependencies_babel_plugin_transform_react_jsx_source":"^6.22.0","npm_package_dependencies_compression_webpack_plugin":"^1.0.1","npm_package_dependencies_file_loader":"^0.11.2","npm_package_dependencies_lodash":"^4.17.4","npm_config_auth_type":"legacy","npm_config_node_version":"9.10.1","npm_config_tag":"latest","OSU_USERNAME":"howl","npm_config_git_tag_version":"true","npm_config_commit_hooks":"true","npm_config_script_shell":"","npm_config_shrinkwrap":"true","GJS_DEBUG_OUTPUT":"stderr","GPG_AGENT_INFO":"/run/user/1000/gnupg/S.gpg-agent:0:1","npm_package_license":"AGPL-3.0-or-later","npm_package_dependencies_classnames":"^2.2.5","npm_package_dependencies_es6_symbol":"^3.1.1","npm_package_dependencies_intl_messageformat":"^2.2.0","npm_package_dependencies_punycode":"^2.1.0","npm_package_devDependencies_eslint_plugin_react":"^7.5.1","npm_config_fetch_retry_factor":"10","npm_config_save_exact":"","npm_config_strict_ssl":"true","XDG_VTNR":"7","npm_package_dependencies_babel_plugin_transform_react_jsx_self":"^6.22.0","npm_config_dev":"","npm_config_globalconfig":"/usr/etc/npmrc","npm_config_init_module":"/home/howl/.npm-init.js","npm_config_parseable":"","LUA_CPATH":"/home/howl/torch-cl/install/lib/?.so;/home/howl/.luarocks/lib/lua/5.1/?.so;/home/howl/torch-cl/install/lib/lua/5.1/?.so;./?.so;/usr/local/lib/lua/5.1/?.so;/usr/local/lib/lua/5.1/loadall.so","PWD":"/home/howl/oc/mastofe","npm_package_dependencies_intl_relativeformat":"^2.1.0","npm_package_dependencies_requestidlecallback":"^0.3.0","npm_package_dependencies_webpack_manifest_plugin":"^1.2.1","npm_package_devDependencies_enzyme":"^3.2.0","npm_package_devDependencies_raf":"^3.4.0","npm_config_globalignorefile":"/usr/etc/npmignore","npm_execpath":"/usr/lib/node_modules/npm/bin/npm-cli.js","DYLD_LIBRARY_PATH":"/home/howl/torch-cl/install/lib:","XDG_DATA_DIRS":"/usr/share/gnome:/home/howl/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share","npm_package_dependencies_react_toggle":"^4.0.1","npm_config_cache_lock_retries":"10","npm_config_searchstaleness":"900","npm_package_dependencies_object_values":"^1.0.4","npm_package_dependencies_prop_types":"^15.5.10","npm_package_dependencies_resolve_url_loader":"^2.2.0","npm_package_dependencies_rimraf":"^2.6.1","npm_config_node_options":"","npm_config_save_prefix":"^","npm_config_scripts_prepend_node_path":"warn-only","npm_package_devDependencies_babel_eslint":"^8.2.1","npm_package_devDependencies_yargs":"^8.0.2","npm_config_group":"1000","npm_config_init_author_email":"","npm_config_searchexclude":"","VTE_VERSION":"5200","npm_package_dependencies_babel_loader":"^7.1.1","npm_package_dependencies_object_fit_images":"^3.2.3","npm_config_git":"git","npm_config_optional":"true","npm_package_dependencies_babel_plugin_transform_decorators_legacy":"^1.3.4","npm_package_dependencies_pg":"^6.4.0","npm_package_dependencies_react":"^16.2.0","npm_package_dependencies_fsevents":"*","npm_config_json":"","INIT_CWD":"/home/howl/oc/mastofe","NODE_ENV":"production"};



function openSystemCache() {
  return caches.open('mastodon-system');
}

function openWebCache() {
  return caches.open('mastodon-web');
}

function fetchRoot() {
  return fetch('/web', { credentials: 'include' });
}

// Cause a new version of a registered Service Worker to replace an existing one
// that is already installed, and replace the currently active worker on open pages.
self.addEventListener('install', function (event) {
  event.waitUntil(Promise.all([openWebCache(), fetchRoot()]).then(function (_ref) {
    var cache = _ref[0],
        root = _ref[1];
    return cache.put('/web', root);
  }));
});
self.addEventListener('activate', function (event) {
  event.waitUntil(self.clients.claim());
});
self.addEventListener('fetch', function (event) {
  var url = new URL(event.request.url);

  if (url.pathname.startsWith('/web')) {
    var asyncResponse = fetchRoot();
    var asyncCache = openWebCache();

    event.respondWith(asyncResponse.then(async function (response) {
      if (response.ok) {
        var cache = await asyncCache;
        await cache.put('/web', response);
        return response.clone();
      }

      throw null;
    }).catch(function () {
      return asyncCache.then(function (cache) {
        return cache.match('/web');
      });
    }));
  } else if (url.pathname === '/auth/sign_out') {
    var _asyncResponse = fetch(event.request);
    var _asyncCache = openWebCache();

    event.respondWith(_asyncResponse.then(async function (response) {
      if (response.ok || response.type === 'opaqueredirect') {
        var cache = await _asyncCache;
        await cache.delete('/web');
      }

      return response;
    }));
  } else if (process.env.CDN_HOST ? url.host === process.env.CDN_HOST : url.pathname.startsWith('/system/')) {
    event.respondWith(openSystemCache().then(async function (cache) {
      var cached = await cache.match(event.request.url);

      if (cached === undefined) {
        var fetched = await fetch(event.request);

        if (fetched.ok) {
          await cache.put(event.request.url, fetched.clone());
        }

        return fetched;
      }

      return cached;
    }));
  }
});


/***/ }),
/* 2 */
/***/ (function(module, exports) {

var MAX_NOTIFICATIONS = 5;
var GROUP_TAG = 'tag';

// Avoid loading intl-messageformat and dealing with locales in the ServiceWorker
var formatGroupTitle = function formatGroupTitle(message, count) {
  return message.replace('%{count}', count);
};

var notify = function notify(options) {
  return self.registration.getNotifications().then(function (notifications) {
    if (notifications.length === MAX_NOTIFICATIONS) {
      // Reached the maximum number of notifications, proceed with grouping
      var group = {
        title: formatGroupTitle(options.data.message, notifications.length + 1),
        body: notifications.sort(function (n1, n2) {
          return n1.timestamp < n2.timestamp;
        }).map(function (notification) {
          return notification.title;
        }).join('\n'),
        badge: '/badge.png',
        icon: '/android-chrome-192x192.png',
        tag: GROUP_TAG,
        data: {
          url: new URL('/web/notifications', self.location).href,
          count: notifications.length + 1,
          message: options.data.message
        }
      };

      notifications.forEach(function (notification) {
        return notification.close();
      });

      return self.registration.showNotification(group.title, group);
    } else if (notifications.length === 1 && notifications[0].tag === GROUP_TAG) {
      // Already grouped, proceed with appending the notification to the group
      var _group = cloneNotification(notifications[0]);

      _group.title = formatGroupTitle(_group.data.message, _group.data.count + 1);
      _group.body = options.title + '\n' + _group.body;
      _group.data = Object.assign({}, _group.data, { count: _group.data.count + 1 });

      return self.registration.showNotification(_group.title, _group);
    }

    return self.registration.showNotification(options.title, options);
  });
};

var handlePush = function handlePush(event) {
  var options = event.data.json();

  options.body = options.data.nsfw || options.data.content;
  options.dir = options.data.dir;
  options.image = options.image || undefined; // Null results in a network request (404)
  options.timestamp = options.timestamp && new Date(options.timestamp);

  var expandAction = options.data.actions.find(function (action) {
    return action.todo === 'expand';
  });

  if (expandAction) {
    options.actions = [expandAction];
    options.hiddenActions = options.data.actions.filter(function (action) {
      return action !== expandAction;
    });
    options.data.hiddenImage = options.image;
    options.image = undefined;
  } else {
    options.actions = options.data.actions;
  }

  event.waitUntil(notify(options));
};

var cloneNotification = function cloneNotification(notification) {
  var clone = {};

  for (var k in notification) {
    clone[k] = notification[k];
  }

  return clone;
};

var expandNotification = function expandNotification(notification) {
  var nextNotification = cloneNotification(notification);

  nextNotification.body = notification.data.content;
  nextNotification.image = notification.data.hiddenImage;
  nextNotification.actions = notification.data.actions.filter(function (action) {
    return action.todo !== 'expand';
  });

  return self.registration.showNotification(nextNotification.title, nextNotification);
};

var makeRequest = function makeRequest(notification, action) {
  return fetch(action.action, {
    headers: {
      'Authorization': 'Bearer ' + notification.data.access_token,
      'Content-Type': 'application/json'
    },
    method: action.method,
    credentials: 'include'
  });
};

var findBestClient = function findBestClient(clients) {
  var focusedClient = clients.find(function (client) {
    return client.focused;
  });
  var visibleClient = clients.find(function (client) {
    return client.visibilityState === 'visible';
  });

  return focusedClient || visibleClient || clients[0];
};

var openUrl = function openUrl(url) {
  return self.clients.matchAll({ type: 'window' }).then(function (clientList) {
    if (clientList.length !== 0) {
      var webClients = clientList.filter(function (client) {
        return (/\/web\//.test(client.url)
        );
      });

      if (webClients.length !== 0) {
        var client = findBestClient(webClients);

        var _ref = new URL(url),
            pathname = _ref.pathname;

        if (pathname.startsWith('/web/')) {
          return client.focus().then(function (client) {
            return client.postMessage({
              type: 'navigate',
              path: pathname.slice('/web/'.length - 1)
            });
          });
        }
      } else if ('navigate' in clientList[0]) {
        // Chrome 42-48 does not support navigate
        var _client = findBestClient(clientList);

        return _client.navigate(url).then(function (client) {
          return client.focus();
        });
      }
    }

    return self.clients.openWindow(url);
  });
};

var removeActionFromNotification = function removeActionFromNotification(notification, action) {
  var actions = notification.actions.filter(function (act) {
    return act.action !== action.action;
  });
  var nextNotification = cloneNotification(notification);

  nextNotification.actions = actions;

  return self.registration.showNotification(nextNotification.title, nextNotification);
};

var handleNotificationClick = function handleNotificationClick(event) {
  var reactToNotificationClick = new Promise(function (resolve, reject) {
    if (event.action) {
      var action = event.notification.data.actions.find(function (_ref2) {
        var action = _ref2.action;
        return action === event.action;
      });

      if (action.todo === 'expand') {
        resolve(expandNotification(event.notification));
      } else if (action.todo === 'request') {
        resolve(makeRequest(event.notification, action).then(function () {
          return removeActionFromNotification(event.notification, action);
        }));
      } else {
        reject('Unknown action: ' + action.todo);
      }
    } else {
      event.notification.close();
      resolve(openUrl(event.notification.data.url));
    }
  });

  event.waitUntil(reactToNotificationClick);
};

self.addEventListener('push', handlePush);
self.addEventListener('notificationclick', handleNotificationClick);

/***/ })
/******/ ]);